---
layout: post
title:  "VPP NAT module investigation"
date:   2019-04-01 12:00:00
categories: VPP
tags: VPP NAT
excerpt: Analyze VPP NAT module
mathjax: true
---
# 1. dslite_ce_decap
DS-Lite customer edge decapsulation.

## 1.1. Introduction
There is 1 node: dslite_ce_decap_node.

# 2. dslite_ce_encap
DS-Lite customer edge encapsulation.

## 2.1. Introduction
There is 1 node: dslite_ce_encap_node.

# 3. dslite_cli

## 3.1. Introduction
This module is not a node, and it provide commands for dual-stack lite.

## 3.2. Command
```
dslite add pool address <ip4-range-start> [- <ip4-range-end>]
 [del]
```
```
show dslite pool
```
```
dslite set aftr-tunnel-endpoint-address <ip6>
```
```
show dslite aftr-tunnel-endpoint-address
```
```
dslite set b4-tunnel-endpoint-address <ip6>
```
```
show dslite b4-tunnel-endpoint-address
```
```
show dslite sessions
```

# 4. dslite_dpo
DS-Lite data path object.

## 4.1. Introduction
This module is not a node.

A Data-Path Object is an object that represents actions that are applied to packets as they are switched through VPP’s data-path.

# 5. dslist_in2out

## 5.1. Introduction
There are 2 nodes: dslite_in2out_node and dslite_in2out_slowpath_node.

# 6. dslite_out2in

## 6.1. Introduction
There is 1 node: dslite_out2in_node.

# 7. dslite

## 7.1. Introduction
This is not a node.

Dual-Stack Lite enables a broadband service provider to share IPv4 addresses among customers by combining two well-known technologies: IPv4-in-IPv6 and NAT.

# 8. in2out_ed

## 8.1. Introduction
NAT44 endpoint-dependent inside to outside network translation.

There are 6 nodes:
* nat44_ed_in2out_node
* nat44_ed_in2out_output_node
* nat44_ed_in2out_slowpath_node
* nat44_ed_in2out_output_slowpath_node
* nat44_ed_in2out_reass_node
* nat44_ed_in2out_reass_output_node

NAT44 endpoint dependent mode enables endpoint dependent filtering and mapping for all sessions needed by some features. Some existing functionality such as service load balancing, twice nat, out2in-only static mappings, unknown protocol dynamic translations and forwarding feature with dynamic translations are now available only in endpoint dependent mode. Endpoint dependent mode use 6-tuple (source IP address, source port, target IP address, target port, protocol, FIB table index) session hash table key instead of 4-tuple (source IP address, source port, protocol, FIB table index).

## 8.2. Detail
NAT44 supports multiple threads, the packets with the same 6-tuple only goes to the same thread, and tranlate port ranges are assigned to different threads.

### 8.2.1. snat_main_per_thread_data_t
This is per thread data.
```
typedef struct
{
  /* Main lookup tables */
  clib_bihash_8_8_t out2in;
  clib_bihash_8_8_t in2out;

  /* Endpoint dependent sessions lookup tables */
  clib_bihash_16_8_t out2in_ed;
  clib_bihash_16_8_t in2out_ed;

  /* Find-a-user => src address lookup */
  clib_bihash_8_8_t user_hash;

  /* User pool */
  snat_user_t *users;

  /* Session pool */
  snat_session_t *sessions;

  /* Pool of doubly-linked list elements */
  dlist_elt_t *list_pool;

  /* NAT thread index */
  u32 snat_thread_index;
} snat_main_per_thread_data_t;
```
#### 8.2.1.1. in2out_ed
This is endpoint dependent sessions lookup tables, and it's VPP classic Bounded-index extensible hash.

* Key is source address, destination address, protocol, fib index, source port and destination port.
* Value is session index.

#### 8.2.1.2. user_hash
Find-a-user => src address lookup.
* Key is source address and fib index.
* Value is user index.

#### 8.2.1.3. list_pool
This is LRU list for session. 

It's array, we can use index to locate array element.

And it contains multiple doubly-linked list, each user has one doubly-linked list, we can use head, next and prev pointer to locate list element.
* Value is session index.

#### 8.2.1.4. users
user_hash table is used to manage users.
```
typedef struct
{
  ip4_address_t addr;
  u32 fib_index;
  u32 sessions_per_user_list_head_index;
  u32 nsessions;
  u32 nstaticsessions;
} snat_user_t;
```
* sessions_per_user_list_head_index is the head index of doubly-linked list for this user.
* nsessions is sesssion number for this user.
* nstaticsessions is static session number for this user.

#### 8.2.1.5. sessions
in2out_ed table and doubly-linked list are used to manage sessions.
```
typedef CLIB_PACKED(struct
{
  /* Outside network key */
  snat_session_key_t out2in;

  /* Inside network key */
  snat_session_key_t in2out;

  /* Flags */
  u32 flags;

  /* Per-user translations */
  u32 per_user_index;
  u32 per_user_list_head_index;

  /* Last heard timer */
  f64 last_heard;

  /* Last HA refresh */
  f64 ha_last_refreshed;

  /* Counters */
  u64 total_bytes;
  u32 total_pkts;

  /* External host address and port */
  ip4_address_t ext_host_addr;
  u16 ext_host_port;

  /* External host address and port after translation */
  ip4_address_t ext_host_nat_addr;
  u16 ext_host_nat_port;

  /* TCP session state */
  u8 state;
  u32 i2o_fin_seq;
  u32 o2i_fin_seq;

  /* user index */
  u32 user_index;
}) snat_session_t;
```
* out2in is outside network key.
* in2out is inside network key.
* last_heard is the timestamp used to mark timeout session.

### 8.2.2. nat44_ed_in2out_node
This node is used before ip4-lookup.

This node is using nat44_ed_in2out_node_fn_inline(). is_slow_path is 0, and is_output_feature is 0.

* Default next node is NAT_IN2OUT_ED_NEXT_LOOKUP.
* Locate IP header, offset is 0.
* If IP ttl is 0, next node is NAT_IN2OUT_ED_NEXT_ICMP_ERROR.
* If IP protocol is not UDP, TCP and ICMP, next node is NAT_IN2OUT_ED_NEXT_SLOW_PATH.
* If it's IP fragment, next node is NAT_IN2OUT_ED_NEXT_REASS.
* If IP protocol is ICMP, next node is NAT_IN2OUT_ED_NEXT_SLOW_PATH.
* Use source address, destination address, protocol, fib index, source port and destination port to search in2out_ed table.
* If this search has no result, next node is NAT_IN2OUT_ED_NEXT_SLOW_PATH.
* If this search has result, use result to get session.
* Replace src address, update IP checksum.
* If IP protocol is TCP, replace source port, update IP checksum, update TCP checksum.
* If IP protocol is UDP, replace source port, UDP checksum is 0.
* Update session counter and timestamp. Timestamp is used to mark timeout session.
* Update doubly-linked list, move session index to list tail.

### 8.2.3. nat44_ed_in2out_output_node
This node is used and after l2-fwd and l3-fwd, before interface-lookup.

This node is using nat44_ed_in2out_node_fn_inline(). is_slow_path is 0, and is_output_feature is 1.

* Default next node is NAT_IN2OUT_ED_NEXT_LOOKUP.
* Locate IP header, offset is save_rewrite_length.
* If IP ttl is 0, next node is NAT_IN2OUT_ED_NEXT_ICMP_ERROR.
* If IP protocol is not UDP, TCP and ICMP, next node is NAT_IN2OUT_ED_NEXT_SLOW_PATH.
* If it's IP fragment, next node is NAT_IN2OUT_ED_NEXT_REASS.
* Call nat_not_translate_output_feature_fwd()
   * Search in2out_ed table for ICMP, TCP and UDP.
   * If this search has result, , use result to get session.
   * If this session is bypass, update session counter and timestamp, and update doubly-linked list.
* If IP protocol is ICMP, next node is NAT_IN2OUT_ED_NEXT_SLOW_PATH.
* Use source address, destination address, protocol, fib index, source port and destination port to search in2out_ed table.
* If this search has no result, next node is NAT_IN2OUT_ED_NEXT_SLOW_PATH.
* If this search has result, use result to get session.
* Replace src address, update IP checksum.
* If IP protocol is TCP, replace source port, update IP checksum, update TCP checksum.
* If IP protocol is UDP, replace source port, UDP checksum is 0.
* Update session counter and timestamp. Timestamp is used to mark timeout session.
* Update doubly-linked list, move session index to list tail.

### 8.2.4. nat44_ed_in2out_slowpath_node
This node is used after nat44-ed-in2out, before ip4-lookup.

This node is using nat44_ed_in2out_node_fn_inline(). is_slow_path is 1, and is_output_feature is 0.

* Default next node is NAT_IN2OUT_ED_NEXT_LOOKUP.
* Locate IP header, offset is 0.
* If IP ttl is 0, next node is NAT_IN2OUT_ED_NEXT_ICMP_ERROR.
* If IP protocol is not UDP, TCP and ICMP, call nat44_ed_in2out_unknown_proto().
   * Use source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port to search in2out_ed table.
   * If this search has result, use result to get session, and replace source address.
   * If this search has no result, need to search other table.
      * Call nat_user_get_or_create() to create NAT user.
         * Use source address and fib index to search user_hash table.
         * If this search has no result, create new user, add to user_hash table, and initialize doubly-linked list.
         * If this search has result, get user.
      * Use source address, 0 as IP protocol, fib index, 0 as source port to search static_mapping_by_local table.
      * If this search has result, use result to get static mapping, replace source address, and create session.
      * If this search has no result, iterate doubly-linked list to get session of this user.
      * If external host address is the same as destination address, check this session.
         * Replace source address with out2in address.
         * Use session out2in address as source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port to search out2in_ed table.
         * If this search has no result, create session.
      * Iterate static mapping addresses, use static mapping address as source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port to search out2in_ed table.
      * If this search has no result, replace source address with static mapping address, and create session.
      * Call nat_ed_session_alloc() to create session.
         * Find oldest session on the list.
         * If oldest session is timeout, replace this session.
            * Move to list tail.
            * Clear session.
            * Call nat_free_session_data().
               * If this session is forwarding bypass, remove this session from in2out_ed table.
               * If this session is endpoint dependent, remove this session from in2out_ed table and out2in_ed table.
               * If this session is not endpoint dependent, remove this session from in2out table and out2in table.
               * Call nat_ha_sdel().
               * If this session is twice NAT, call snat_free_outside_address_and_port().
               * Call snat_free_outside_address_and_port().
         * If oldest session is not timeout, add new session.
            * Create new session and add to list tail.
      * Insert in2out_ed table.
         * Key is in2out address as source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port.
         * Value is session index.
      * Insert out2in_ed table.
         * Key is out2in address as source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port.
         * Value is session index.
   * Update IP checksum.
   * Update session counter and timestamp. Timestamp is used to mark timeout session.
   * Update doubly-linked list, move session index to list tail.
   * Call nat44_ed_hairpinning_unknown_proto() for hairpinning.
      * Search out2in_ed table.
      * If this search has result, replace destination address.
      * If this search has no result, search static_mapping_by_external table.
      * If this search has result, replace destination address.
      * Update IP checksum.
* If IP protocol is ICMP, call icmp_in2out_ed_slow_path().
   * Call icmp_in2out().
      * Call icmp_match_in2out_ed() to find next node.
         * Call icmp_get_ed_key() to get key.
         * Search in2out_ed table.
         * If this search has result, get session.
         * If this search has no result, enter slow path.
            * Call nat44_ed_not_translate_output_feature().
               * Search in2out_ed table.
               * If this search has result, get session.
               * If this session is forwarding bypass, update session counter, update LRU list, do not translate.
               * If this session is not forwarding bypass, do translate.
            * Call nat44_ed_not_translate().
               * Search out2in_ed table, if this search has result, do translate.
               * Call snat_static_mapping_match(), if it has result, do translate.
               * If forwarding is enabled, do not translate.
               * Call snat_not_translate_fast() to decide.
            * Call slow_path_ed().
               * Call snat_static_mapping_match() to match static mapping by local address and port.
               * If no match, call snat_alloc_outside_address_and_port() to create dynamic translation.
                  * port range is assigned to multiple threads.
               * If TCP flag is not SYNC, drop it. Only use single thread, first TCP is sync, create NAT session in slow path, and next TCP will not enter slow path.
               * Call nat_user_get_or_create() to get NAT user.
               * Call nat_ed_session_alloc() to create session.
               * Add to in2out_ed table.
               * Add to out2in_ed table.
               * Call nat_ha_sadd().
      * Verify IP checksum.
      * Replace source address and update IP checksum.
      * If this is not ICMP error message, replace ICMP identifier and update ICMP checksum.
      * If this is ICMP error message, process inner IP.
         * Verify inner IP checksum.
         * Update inner destination IP address.
         * Update inner IP header checksum.
         * If inner IP protocol is ICMP, replace ICMP identifier, update ICMP checksum.
         * If inner IP protocol is TCP or UDP, replace destination port, update ICMP checksum.
         * Call snat_icmp_hairpinning() for hairpinning.
   * Update session counter and timestamp. Timestamp is used to mark timeout session.
   * Update doubly-linked list, move session index to list tail.
* Use source address, destination address, protocol, fib index, source port and destination port to search in2out_ed table.
* If this search has result, use result to get session.
* If this search has no result, enter slow path.
   * Call nat44_ed_not_translate().
   * Call slow_path_ed().
* Replace src address, update IP checksum.
* If IP protocol is TCP, replace source port, update IP checksum, update TCP checksum.
* If IP protocol is UDP, replace source port, UDP checksum is 0.
* Update session counter and timestamp. Timestamp is used to mark timeout session.
* Update doubly-linked list, move session index to list tail.

### 8.2.5. nat44_ed_in2out_output_slowpath_node
This node is used after nat44-ed-in2out-output, before interface-output.

This node is using nat44_ed_in2out_node_fn_inline(). is_slow_path is 1, and is_output_feature is 1.

* Default next node is NAT_IN2OUT_ED_NEXT_LOOKUP.
* Locate IP header, offset is save_rewrite_length.
* If IP ttl is 0, next node is NAT_IN2OUT_ED_NEXT_ICMP_ERROR.
* If IP protocol is not UDP, TCP and ICMP, call nat44_ed_in2out_unknown_proto().
   * Use source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port to search in2out_ed table.
   * If this search has result, use result to get session, and replace source address.
   * If this search has no result, need to search other table.
      * Call nat_user_get_or_create() to create NAT user.
         * Use source address and fib index to search user_hash table.
         * If this search has no result, create new user, add to user_hash table, and initialize doubly-linked list.
         * If this search has result, get user.
      * Use source address, 0 as IP protocol, fib index, 0 as source port to search static_mapping_by_local table.
      * If this search has result, use result to get static mapping, replace source address, and create session.
      * If this search has no result, iterate doubly-linked list to get session of this user.
      * If external host address is the same as destination address, check this session.
         * Replace source address with out2in address.
         * Use session out2in address as source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port to search out2in_ed table.
         * If this search has no result, create session.
      * Iterate static mapping addresses, use static mapping address as source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port to search out2in_ed table.
      * If this search has no result, replace source address with static mapping address, and create session.
      * Call nat_ed_session_alloc() to create session.
         * Find oldest session on the list.
         * If oldest session is timeout, replace this session.
            * Move to list tail.
            * Clear session.
            * Call nat_free_session_data().
               * If this session is forwarding bypass, remove this session from in2out_ed table.
               * If this session is endpoint dependent, remove this session from in2out_ed table and out2in_ed table.
               * If this session is not endpoint dependent, remove this session from in2out table and out2in table.
               * Call nat_ha_sdel().
               * If this session is twice NAT, call snat_free_outside_address_and_port().
               * Call snat_free_outside_address_and_port().
         * If oldest session is not timeout, add new session.
            * Create new session and add to list tail.
      * Insert in2out_ed table.
         * Key is in2out address as source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port.
         * Value is session index.
      * Insert out2in_ed table.
         * Key is out2in address as source address, destination address, IP protocol, fib index, 0 as source port, 0 as destination port.
         * Value is session index.
   * Update IP checksum.
   * Update session counter and timestamp. Timestamp is used to mark timeout session.
   * Update doubly-linked list, move session index to list tail.
   * Call nat44_ed_hairpinning_unknown_proto() for hairpinning.
      * Search out2in_ed table.
      * If this search has result, replace destination address.
      * If this search has no result, search static_mapping_by_external table.
      * If this search has result, replace destination address.
      * Update IP checksum.
* If IP protocol is ICMP, call icmp_in2out_ed_slow_path().
   * Call icmp_in2out().
      * Call icmp_match_in2out_ed() to find next node.
         * Call icmp_get_ed_key() to get key.
         * Search in2out_ed table.
         * If this search has result, get session.
         * If this search has no result, enter slow path.
            * Call nat44_ed_not_translate_output_feature().
               * Search in2out_ed table.
               * If this search has result, get session.
               * If this session is forwarding bypass, update session counter, update LRU list, do not translate.
               * If this session is not forwarding bypass, do translate.
            * Call nat44_ed_not_translate().
               * Search out2in_ed table, if this search has result, do translate.
               * Call snat_static_mapping_match(), if it has result, do translate.
               * If forwarding is enabled, do not translate.
               * Call snat_not_translate_fast() to decide.
            * Call slow_path_ed().
               * Call snat_static_mapping_match() to match static mapping by local address and port.
               * If no match, call snat_alloc_outside_address_and_port() to create dynamic translation.
                  * port range is assigned to multiple threads.
               * If TCP flag is not SYNC, drop it. Only use single thread, first TCP is sync, create NAT session in slow path, and next TCP will not enter slow path.
               * Call nat_user_get_or_create() to get NAT user.
               * Call nat_ed_session_alloc() to create session.
               * Add to in2out_ed table.
               * Add to out2in_ed table.
               * Call nat_ha_sadd().
      * Verify IP checksum.
      * Replace source address and update IP checksum.
      * If this is not ICMP error message, replace ICMP identifier and update ICMP checksum.
      * If this is ICMP error message, process inner IP.
         * Verify inner IP checksum.
         * Update inner destination IP address.
         * Update inner IP header checksum.
         * If inner IP protocol is ICMP, replace ICMP identifier, update ICMP checksum.
         * If inner IP protocol is TCP or UDP, replace destination port, update ICMP checksum.
         * Call snat_icmp_hairpinning() for hairpinning.
   * Update session counter and timestamp. Timestamp is used to mark timeout session.
   * Update doubly-linked list, move session index to list tail.
* Use source address, destination address, protocol, fib index, source port and destination port to search in2out_ed table.
* If this search has result, use result to get session.
* If this search has no result, enter slow path.
   * Call nat44_ed_not_translate_output_feature().
   * Call slow_path_ed().
* Replace src address, update IP checksum.
* If IP protocol is TCP, replace source port, update IP checksum, update TCP checksum.
* If IP protocol is UDP, replace source port, UDP checksum is 0.
* Update session counter and timestamp. Timestamp is used to mark timeout session.
* Update doubly-linked list, move session index to list tail.

### 8.2.6. nat44_ed_in2out_reass_node
This node is used after nat44-ed-in2out, before ip4-lookup.

This node is using nat44_ed_in2out_reass_node_fn_inline(). is_output_feature is 0.

* Call nat_reass_is_drop_frag(), drop IP fragment if configured.
* Locate IP header, offset is 0.
* Call nat_ip4_reass_find_or_create() to get reassemble.
* Call ip4_is_first_fragment(), if this is the first fragment.
   * If this is ICMP.
      * Call icmp_in2out_ed_slow_path().
      * Call nat_ip4_reass_get_frags().
   * Search in2out_ed table.
   * If this search has no result.
      * Call nat44_ed_not_translate().
      * Call slow_path_ed().
   * If this search has result, get session.
   * Call nat_ip4_reass_get_frags().
* If this is not the first fragment.
* Replace source address, and update IP checksum.
* Call ip4_is_first_fragment(), if this is the first fragment.
   * If this is TCP.
      * Replace source port, update TCP checksum.
   * If this is not TCP.
      * Replace source port, UDP checksum is 0.
* Call nat44_reass_hairpinning().
* Call nat44_session_update_counters() to update session counter and timestamp.
* Call nat44_session_update_counters() to update doubly-linked list.

### 8.2.7. nat44_ed_in2out_reass_output_node
This node is used after nat44-ed-in2out-output, before interface-output.

This node is using nat44_ed_in2out_reass_node_fn_inline(). and is_output_feature is 1.

* Call nat_reass_is_drop_frag(), drop IP fragment if configured.
* Locate IP header, offset is save_rewrite_length.
* Call nat_ip4_reass_find_or_create() to get reassemble.
* Call ip4_is_first_fragment(), if this is the first fragment.
   * If this is ICMP.
      * Call nat44_ed_not_translate_output_feature().
      * Call icmp_in2out_ed_slow_path().
      * Call nat_ip4_reass_get_frags().
   * Search in2out_ed table.
   * If this search has no result.
      * Call nat_not_translate_output_feature_fwd().
      * Call slow_path_ed().
   * If this search has result, get session.
   * Call nat_ip4_reass_get_frags().
* If this is not the first fragment.
* Replace source address, and update IP checksum.
* Call ip4_is_first_fragment(), if this is the first fragment.
   * If this is TCP.
      * Replace source port, update TCP checksum.
   * If this is not TCP.
      * Replace source port, UDP checksum is 0.
* Call nat44_reass_hairpinning().
* Call nat44_session_update_counters() to update session counter and timestamp.
* Call nat44_session_update_counters() to update doubly-linked list.

# 9. in2out

## 9.1. Introduction
NAT44 inside to outside network translation.

There are 6 nodes:
* snat_in2out_node
* snat_in2out_output_node
* snat_in2out_slowpath_node
* snat_in2out_output_slowpath_node
* nat44_in2out_reass_node
* snat_in2out_fast_node

## 9.2. Detail

### 9.2.1. snat_in2out_node
This node is used before ip4-lookup.

This node is using snat_in2out_node_fn_inline(). is_slow_path is 0, and is_output_feature is 0.

* Locate IP header, offset is 0.
* If IP ttl is 0, next node is NAT_IN2OUT_NEXT_ICMP_ERROR.
* If IP protocol is not UDP, TCP and ICMP, next node is NAT_IN2OUT_NEXT_SLOW_PATH.
* If it’s IP fragment, next node is NAT_IN2OUT_NEXT_REASS.
* If IP protocol is ICMP, next node is NAT_IN2OUT_NEXT_SLOW_PATH.
* Use source address, source port, protocol and fib index to search in2out table.
* If this search has no result, next node is NAT_IN2OUT_NEXT_SLOW_PATH.
* If this search has result, use result to get session.
* Replace src address, update IP checksum.
* If IP protocol is TCP, replace source port, update IP checksum, update TCP checksum.
* If IP protocol is UDP, replace source port, UDP checksum is 0.
* Update session counter and timestamp. Timestamp is used to mark timeout session.
* Update doubly-linked list, move session index to list tail.

### 9.2.2. snat_in2out_output_node
This node is used after ip4-lookup, before interface-output.

This node is using snat_in2out_node_fn_inline(). is_slow_path is 0, and is_output_feature is 1.

* Locate IP header, offset is save_rewrite_length.
* If IP ttl is 0, next node is NAT_IN2OUT_NEXT_ICMP_ERROR.
* If IP protocol is not UDP, TCP and ICMP, next node is NAT_IN2OUT_NEXT_SLOW_PATH.
* If it’s IP fragment, next node is NAT_IN2OUT_NEXT_REASS.
* If IP protocol is ICMP, next node is NAT_IN2OUT_NEXT_SLOW_PATH.
* Use source address, source port, protocol and fib index to search in2out table.
* If this search has no result, next node is NAT_IN2OUT_NEXT_SLOW_PATH.
* If this search has result, use result to get session.
* Replace src address, update IP checksum.
* If IP protocol is TCP, replace source port, update IP checksum, update TCP checksum.
* If IP protocol is UDP, replace source port, UDP checksum is 0.
* Update session counter and timestamp. Timestamp is used to mark timeout session.
* Update doubly-linked list, move session index to list tail.

### 9.2.3. snat_in2out_slowpath_node
This node is used after nat44-in2out, before ip4-lookup.

This node is using snat_in2out_node_fn_inline(). is_slow_path is 1, and is_output_feature is 0.

* Locate IP header, offset is 0.
* If IP ttl is 0, next node is NAT_IN2OUT_NEXT_ICMP_ERROR.
* If IP protocol is not UDP, TCP and ICMP, call nat_in2out_sm_unknown_proto().
   * Use source address and fib index to search static_mapping_by_local.
   * Replace source address and update IP checksum.
   * Call nat_hairpinning_sm_unknown_proto() for hairpinning.
* If IP protocol is ICMP, call icmp_in2out_slow_path().
   * Call icmp_in2out().
   * Update session counter and timestamp. Timestamp is used to mark timeout session.
   * Update doubly-linked list, move session index to list tail.
* Use source address, source port, protocol and fib index to search in2out table.
* If this search has no result, enter slow path.
   * Call snat_not_translate().
      * Use destination address and destination port to search out2in table, if this search has result, do translate.
      * Use destination address and destination port to search static mapping table, if this search has result, do translate.
      * Call snat_not_translate_fast().
   * Call slow_path().
* If this search has result, use result to get session.
* Replace src address, update IP checksum.
* If IP protocol is TCP, replace source port, update IP checksum, update TCP checksum.
* If IP protocol is UDP, replace source port, UDP checksum is 0.
* Update session counter and timestamp. Timestamp is used to mark timeout session.
* Update doubly-linked list, move session index to list tail.

### 9.2.4. snat_in2out_output_slowpath_node
This node is used after nat44-in2out-output, before interface-output.

This node is using snat_in2out_node_fn_inline(). is_slow_path is 1, and is_output_feature is 1.

### 9.2.5. nat44_in2out_reass_node
This node is used after nat44-in2out, before ip4-lookup.

### 9.2.6. snat_in2out_fast_node
This node is used before ip4-lookup.

When only support static mapping, and don't need connection tracking, this node is used.






